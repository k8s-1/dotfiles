-- advanced
-- https://vim.rtorr.com/

-- :Lazy -- to update

-- :colo :colorscheme
-- :colo murphy
-- :colo oxocarbon -- dark

-- :norm -- invoke normal mode from command, combine with visual select to perform bulk operation
-- e.g.
-- :norm Istring -- insert string at start of line, alternatively use vblock mode C-v0I
-- :norm Astring -- append string to end of line, alternatively use vblock mode C-v$A

-- arithmetics
-- :=2*(1+1) -- execute expression and save to :reg
-- C-a -- increment number
-- C-x -- decrement number

-- tip: numbered list
-- 10o0.
-- visual select lines, then...
-- gC-a -- increment first number in line

-- visual mode
-- C-v -- block mode
-- C-V -- line mode
-- o -- toggle endpoint of visual to shrink/expand

-- :reg :registers / macros
-- :h clipboard
-- qa -- record new macro into register a
-- @qa -- call macro a
-- @@ -- repeat macro
-- "+y -- yank to system reg
-- "+p -- paste from system reg
-- "ay -- yank to letter a reg
-- "0p -- paste from previous numbered reg, automatically generated by deletes
-- ":p -- paste from expression register
-- 
-- :reg
--  0 - last yank
--  " - unnamed register, last delete or yank
--  % - current file name
--  # - alternate file name
--  * - clipboard contents
--  + - clipboard contents
--  / - last search pattern
--  : - last command-line
--  . - last inserted text
--  - - last small (less than a line) delete
--  = - expression register
--  _ - black hole register

-- commands
-- :r!command -- paste command output
--
-- first visually select, then...
-- '<,'>:!jq . -- use jq on visual select
-- '<,'>:!sort -- sort visually selected line
-- '<,'>:!sort | uniq -- sort visually selected line and then pipe it to uniq

-- change/deletion
-- dap -- delete around paragraph () {}
-- cip -- delete inside paragraph () {}
-- ci( -- change inside ()
-- ci" -- change inside " quotes
-- ciw -- change inside word
-- gU -- change uppercase up to motion
-- gu -- lower case
-- ~ -- lower/uppercase toggle
-- r -- single char replace
-- R -- overwrite until ESC pressed
-- :g/{pattern}/d -- delete all lines containing pattern
-- :g!/{pattern}/d -- delete all lines not containing pattern

-- insert mode
-- ea -- insert end of word
-- C-w -- delete word before cursor during insert mode
-- C-p -- insert auto-complete
-- C-r -- insert register x contents
-- C-o -- issue one normal mode command

-- indent
-- >>
-- <<
-- >% -- indent block with () / {}
-- <% -- de-indent block with () / {}

-- navigation
-- % -- matching/next bracket
-- f" -- go to char "
-- t" -- go to before char "
-- ; -- cycle forwards
-- , -- cycle backwards
-- C-o -- scroll up
-- C-d -- scroll down
-- gg -- top
-- GG -- bottom
-- } -- next paragraph
-- { -- prev paragraph

-- :fold
-- za -- toggle fold
-- zf -- manually define fold up to motion
-- zr -- open all folds one level
-- zm -- close all folds one level

-- file difference
-- :diffsplit <PATH>
-- :diffo[ff] -- turn off

-- view
-- :vs -- split screen
-- zz -- cursor to center
-- zt -- cursor to top
-- zb -- cursor to bottom

-- -- string replace
-- search for foo in all .txt files recursively + populate quick fix :copen, see fzf.lua for alternative,
-- :vim[grep] /foo/ **/*.txt
-- :copen -- open quick fix window
-- apply global+confirm change operation to :copen
-- :cdo %s/foo/bar/gc
-- :ccl -- close quick fix

-- replace all lines
-- :%s
-- replace single line
-- :s

-- global replace + capture group
-- :%s/\(.*\)/\1/g

-- :marks
-- ma -- set new mark at a
-- 'a -- go to mark a
-- mA -- set new global mark at A, available on all buffers
-- '' -- switch between last mark
-- `. -- go to position of last change
-- C-o -- previous :jumps
-- C-i -- next :jumps

-- :ls :buffers
-- C-6 -- toggle buffer
-- <leader>-b -- fzf buffers
-- :edit <PATH> -- open file in new buffer
-- :edit <TAB> + C- + <TAB> to get path

-- search
-- ?pattern -- search backward
-- /pattern
-- noh -- highlight off

vim.g.mapleader = " " -- leader key as space
vim.g.maplocalleader = " "

--  See `:help vim.keymap.set()`
-- Set highlight on search, but clear on pressing <Esc> in normal mode
vim.opt.hlsearch = true
vim.keymap.set("n", "<Esc>", "<cmd>nohlsearch<CR>", { noremap = true })

-- Diagnostic keymaps
vim.keymap.set("n", "[d", vim.diagnostic.goto_prev, { desc = "Go to previous [D]iagnostic message", noremap = true })
vim.keymap.set("n", "]d", vim.diagnostic.goto_next, { desc = "Go to next [D]iagnostic message", noremap = true })
vim.keymap.set("n", "<leader>m", vim.diagnostic.open_float, { desc = "Show diagnostic [E]rror messages", noremap = true })
vim.keymap.set("n", "<leader>q", vim.diagnostic.setloclist, { desc = "Open diagnostic [Q]uickfix list", noremap = true })

-- Exit terminal mode in the builtin terminal with a shortcut that is a bit easier
-- for people to discover. Otherwise, you normally need to press <C-\><C-n>, which
-- is not what someone will guess without a bit more experience.
--
-- NOTE: This won't work in all terminal emulators/tmux/etc. Try your own mapping
-- or just use <C-\><C-n> to exit terminal mode
vim.keymap.set("t", "<Esc><Esc>", "<C-\\><C-n>", { desc = "Exit terminal mode", noremap = true })

-- Keybinds to make split navigation easier.
--  Use CTRL+<hjkl> to switch between windows
--  See `:help wincmd` for a list of all window commands
vim.keymap.set("n", "<C-h>", "<C-w><C-h>", { desc = "Move focus to the left window", noremap = true })
vim.keymap.set("n", "<C-l>", "<C-w><C-l>", { desc = "Move focus to the right window", noremap = true })
vim.keymap.set("n", "<C-j>", "<C-w><C-j>", { desc = "Move focus to the lower window", noremap = true })
vim.keymap.set("n", "<C-k>", "<C-w><C-k>", { desc = "Move focus to the upper window", noremap = true })


-- Resize splits with meta/alt key.
vim.keymap.set('n', '<M-j>', ':resize -2<CR>', { noremap = true, silent = true })
vim.keymap.set('n', '<M-k>', ':resize +2<CR>', { noremap = true, silent = true })
vim.keymap.set('n', '<M-h>', ':vertical resize +2<CR>', { noremap = true, silent = true })
vim.keymap.set('n', '<M-l>', ':vertical resize -2<CR>', { noremap = true, silent = true })
